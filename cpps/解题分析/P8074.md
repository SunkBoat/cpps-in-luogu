# P8074

先说我的假做法。



设当前是第 $i$ 个。



那么我们找出


$$
\min\{\min(|x_i-x_j|, |y_i-y_j|, |z_i-z_j|)\}(1 \le j < i)
$$


虽然这是 $O(n^2)$ 的，可是[理论上可以通过在堆上二分或者建平衡树实现 $O(n \log n)$](https://www.luogu.com.cn/discuss/586281)，但我没逝过（tcl）。



Hack：

```md
3
0 0 0
114514 114514 114514
2333 2333 2333
```

此时答案是 $116847$，而正解是 $114514$，原因显然。

有图为证。

![](https://camo.githubusercontent.com/9ddb3bc702b0962eb6550978f87f6b9ad33ed495b6e271dae55f714086e7ac3d/68747470733a2f2f73312e617831782e636f6d2f323032332f30332f32342f7070423333644a2e706e67)

![](https://camo.githubusercontent.com/078060a3e3a4fc7ad677f2a2a72526a5b82a04d771a73b62d02f7c1474f11bd9/68747470733a2f2f73312e617831782e636f6d2f323032332f30332f32342f70704233594a312e706e67)

### 正解

按 $x_i$ 从小至大排序，$y_i$，$z_i$ 也排一遍。



然后对于所有 $2 \le i \le n$，对 $x_i$ 和 $x_{i-1}$， $y_i$ 和 $y_{i-1}$， $z_i$ 和 $z_{i-1}$ 建边，之后最小生成树。



#### 如何保证连通



很显然，对 $x_i$ 和 $x_{i-1}$ 建边是一条链。



这样子，由于没有重边，且会建 $n-1$ 次，所以是联通的。



$y_i$ 和 $y_{i-1}$ ， $z_i$ 和 $z_{i-1}$ 同理。



会发现这其实是 $3$ 条链交叉在一起的图。不放了。



#### 如何保证花费最小



反证法。以排序过的 $x$ 举例。剩下两个同理。



假如有一个值 $x_j(j < i)$ ， $x_i - x_{i-1} > x_i - x_j$。



那么由于 $x_i$ 相等， $x_j, x_{i-1} < x_i$



所以 $x_j > x_{i-1}$。



又因为 $j < i$ 且 $j \ne i - 1$，所以 $j < i - 1$。



因为我们是排序过的，所以 $\forall 1 \le a < b \le n, x_a < x_b$。



所以 $x_j < x_{i-1}$。



与前面条件矛盾。



如果扩大至三维呢？



假如 $i$ 与 $j$ 要连边，那么假如路径 $a$ 是最短的，但是我们使用了 $b$ 这条路径。



可是，由于最小生成树的运行方式，我们 **一定** 会选择 $a$。所以是最小花费的。

![](https://camo.githubusercontent.com/c52deac9664069bb95b7dc9f3a365462bf0c0c6d33ed849aa5040a4c8e8eaff8/68747470733a2f2f73312e617831782e636f6d2f323032332f30332f32342f70704233364a492e706e67)



#### 能否可以在建边之后遍历枚举距离最小的边并直接加进去



由于每一个点 $i$ 都只会连 $3$ 条边，所以这样是 $O(n)$ 的。



但是会有环



所以还是要用最小生成树。

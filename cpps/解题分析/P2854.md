~~github 没有 latex，凑合着看吧（（~~    
~~wtf github 居然有 latex？！~~

语文不好轻喷

以下做法源自 wyz 巨佬

我们设 $f(i, j)$ 为铺 $1 \sim i$ 的滑道（？，花费不超过 $j$ 的最大收益。

那么我们可以用 `vector` 预先存好每一个滑道的数据，像这样子：

```cpp
for (int i = 1; i <= n; ++i) {
    int x, w, c;
    int f;
    scanf ("%d%d%lld%d", &x, &w, &f, &c);
    g t;
    t.c = c; t.f = f; t.x = x + 1;
    v[x + w + 1].push_back(t);
}
```

以后设 $vc(x, y)$ 为以 $x$ 为终点的第 $y$ 个滑道的代价，$vf(x, y)$ 为以 $x$ 为终点的第 $y$ 个滑道的收益，$vx(x, y)$ 为以 $x$ 为终点的第 $y$ 个滑道的起点。

由于从 $1$ 开始更加方便，不妨全体加一（包括 $l$）

那么，状态转移就好写了。

初始的时候显然有 $f(1, i) = 0$。

由于答案不可能是负数，所以无解就搞 $-\infty$ 即可。

接下来枚举每一个 `vector`（循环变量以 $k$ 表示）。对于第 $f(i, j)$ 不铺该滑道收益显然不变，铺了滑道，那么代价就需要增加 $vc(i, k)$，收益可以增加 $vf(i, k)$，而剩下一部分的最大收益就是 $f(vx(i, k), j - vc(i, k))$

综合起来即为

$$
\forall i > 1, f(i, j) = \max(f(i, j), f(vx(i, k), j - vc(i, k) + vf(i, k))
$$

最后答案就是 $f(L, B)$。

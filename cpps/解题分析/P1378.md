# 严厉批判自己，代码几乎和 [题解](https://www.luogu.com.cn/blog/shenhy1205/solution-p1378) 一样。警告一次，下不为例

-----

设


$dis(x_1, y_1, x_2, y_2) = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$

。（这就是欧氏距离）



------

由于 $N \le 6$ ，所以可以枚举全排列，找出所有圆所放置的顺序。



接下来我们考虑如何去计算长方形盒子剩余的最小空间。显然，可以转化成总面积减去圆面积之和的最大值，即


$\operatorname{abs}(x'-x)\cdot\operatorname{abs}(y'-y)-\max\{\sum\limits_{i=1}^n \pi r_i^2\}$
。

那么，怎么求出 $r_i$ 呢？



一种方法是枚举 $1 \sim 1000$ ，求出 $r_i$ 符不符合。进一步的，可以用二分完成 ~~但是我没有试过~~



```cpp
int g(int a, int b, int d) {
	for (int i = 1; i <= 1000; ++i) {
//		cout<<a<<' '<<b<<' '<<i<<endl;
		if (!pd_wall(a, b, i) || !pd_circle(a, b, i, d)) return i - 1;
	}
	return 1000;
}
```

$$
\small\color{grey}\text{人类高质量代码.jpeg}
$$

另一种方法是寻找 其他油滴或者框子的边界 离该点的最小值。由于 **圆的半径相等**，很明显，选择其他的会导致相交。



![](https://camo.githubusercontent.com/371495268edf8e79a01aef2dfc9d205d6d6fdfddf6350966e35f9efb4a8d8c5a/68747470733a2f2f73312e617831782e636f6d2f323032332f30332f32372f707079647a68362e706e67)



例如，红色的圆并没有考虑到右上角的圆，虽然没有超出边界，但是不可避免的和右上角的圆相交了。



怎么判断距离？



由于边界是一条 **在坐标轴上的** 线段，所以离边界的最短长度线段是垂直的，即 **在坐标轴上**。

![](https://camo.githubusercontent.com/ed3f6611d5d10a27a7a5c4f9808c808529387798fb8b142b1e6d2a11535b24f1/68747470733a2f2f73312e617831782e636f6d2f323032332f30332f32382f707079687a344f2e706e67)

这样，显然最短长度线段的一个点是 $(x_i, y_i)$ ，另外的是 $(x_i, y)$ ， $(x_i, y')$ ， $(x, y_i)$ ， $(x', y_i)$ 。



由于这四个点中 **有一个坐标必然是和原来的坐标一样** ，所以距离就是 $y_i - y, y' - y_i, x_i - x, x' - x_i$ 。



如何求点到其他圆的距离？



如图。



![](https://camo.githubusercontent.com/4eec025ab4667096d7bc6be5a309c0c98cb37a753801bdff851f05559c159a05/68747470733a2f2f73312e617831782e636f6d2f323032332f30332f32382f707063693655302e706e67)

将圆心 $A$ 与点 $C$ 连接，交圆边于 $D$ 。显然 $AD$ 的长度就是半径的长度。答案即为 $AC - AD$



证明这是最小的



我们还有 $AB + BC$ 。

因为两点之间线段最短，所以 $AC < AB + BC$ 。

因为圆的半径相等，所以 $AD = AB$ 。

所以 $AB + BC - AB > AC - AD$ ，即 $BC > DC$ 。



所以这是最小的。

所以我们之需要求出 $AC$ 的长度减去 半径 就可以了，即 $dis(x_a, y_a, x_c, y_c)$ 。



剩下的就是代码了 qwq
